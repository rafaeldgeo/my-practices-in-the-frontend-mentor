const textArea = document.querySelector(".form__text");
const checkboxes = document.querySelectorAll(".form__checkbox");
const inputLimitCharacters = document.querySelector(".form__input");
const spanCardsValue = document.querySelectorAll(".card__value");
const spanNoSpace = document.querySelector(".card__title-no-space");
const diVWarningLimit = document.querySelector(".form__warning-limit-characters");
const spanWarningLimitValue = diVWarningLimit.querySelector(".form__warning-limit-value");
const spanReadingTime = document.querySelector(".form__reading-time-result");

const PATTERN_LIMIT_INPUT = /[^0-9]/g; // generated by IA 
const PATTERN_EXCLUDE_SPACES = /[\s]/g; // generated by IA
const PATTERN_WORDS = /\p{L}+/gu; // generated by IA
const PATTERN_SENTENCE = /[^.]+\./g; // generated by IA

// check if checkbox exclude spaces is checked
function CheckActivatedExcludeSpace() {
    let isChecked = checkboxes[0].checked;
    return isChecked;
}

// Update the result in the cards
function updateCharactersStats(text) {
    const isCheckedExcludeSpaces = CheckActivatedExcludeSpace();
    let characters = 0;
    let words = 0;
    let sentences = 0;
    let readingTime = 0;
    let isExcludeSpaces = false;
    let limitCharacters = { isExceed: false, value: undefined };
    if (isCheckedExcludeSpaces) {
        characters = countCharacters(text, "noSpaces");
        isExcludeSpaces = true;
    } else {
        characters = countCharacters(text, "original");
        limitCharacters = checkLimitCharacters(characters);
    }
    words = countWordsSenteces(text, "original").totalWords;
    sentences = countWordsSenteces(text, "original").totalSentences;
    readingTime = calcReadingTime(words);
    updateUI({ characters, words, sentences, readingTime, isExcludeSpaces, limitCharacters });
}

// exclude spaces characters
function excludeSpaces(text) {
    return text.replace(PATTERN_EXCLUDE_SPACES, "");
}

// Sanitize input when the user types letter and symbols
inputLimitCharacters.addEventListener("input", () => {
    inputLimitCharacters.value = inputLimitCharacters.value.replace(PATTERN_LIMIT_INPUT, "");
});

// check the limit of characters
function checkLimitCharacters(numCharacters) {
    const valueLimit = Number(inputLimitCharacters.value);
    let limitDefined = valueLimit > 0 ? valueLimit : undefined;
    if (numCharacters >= limitDefined) {
        return { isExceed: true, value: limitDefined };
    } else {
        return { isExceed: false, value: limitDefined };
    }
}

// define the checkbox selected 
function setting(e) {
    const selectedOption = e.target;
    switch (selectedOption.id) {
        case "exclude-spaces":
            captureTextRealTime();
            break;
        case "limit-caracters":
            showInputLimitCharacters(selectedOption);
            break;
        default:
    }
}

// input of the caracteres
function captureTextRealTime() {
    const text = textArea.value.trim();
    updateCharactersStats(text);
}

// count the characters by type of the text. Exclude spaces or original 
function countCharacters(text, typeText) {
    const value = typeText === "noSpaces" ? excludeSpaces(text).length : text.length;
    return value;
}

// count the words and senteces
function countWordsSenteces(text) {
    const totalCharacters = countCharacters(text, "original");
    const totalWords = totalCharacters > 0 ? text.match(PATTERN_WORDS).length : 0;
    const totalSentences = totalCharacters > 0 && text.match(PATTERN_SENTENCE) ? text.match(PATTERN_SENTENCE).length : 0;
    return { totalWords, totalSentences }
}

// calculate the time to reading
function calcReadingTime(words) {
    const WORD_PER_MINUTE = 200;
    return words / WORD_PER_MINUTE;
}

// show the input to define limite of characters
function showInputLimitCharacters(checkbox) {
    if (checkbox.checked) {
        inputLimitCharacters.setAttribute("aria-hidden", "false");
        inputLimitCharacters.focus();
    } else {
        inputLimitCharacters.setAttribute("aria-hidden", "true");
        inputLimitCharacters.value = "";
        captureTextRealTime();
    }
    inputLimitCharacters.classList.toggle("form__input--active", checkbox.checked);
}

// show the values in the stats on the cards
function updateUI(states) {

    // show label No Space
    if (Object.hasOwn(states, "isExcludeSpaces")) {
        if (states["isExcludeSpaces"]) {
            spanNoSpace.setAttribute("aria-hidden", "false");
        } else {
            spanNoSpace.setAttribute("aria-hidden", "true");
        }
        spanNoSpace.classList.toggle("card__title-no-space--active", states["isExcludeSpaces"]);
    }

    // show result in the cards
    spanCardsValue.forEach(card => {
        if (Object.hasOwn(states, card.id)) {
            card.textContent = states[card.id] > 0 ? states[card.id].toString().padStart(2, "0") : "00";
        }
    })

    // show the time to reading
    if (Object.hasOwn(states, "readingTime")) {
        const readingTime = states["readingTime"];
        if (readingTime === 0) {
            spanReadingTime.textContent = "0 minute";
        } else if (readingTime > 0 && readingTime < 1) {
            spanReadingTime.textContent = "< 1 minute";
        } else {
            spanReadingTime.textContent = `${Math.ceil(readingTime)} minutes`;
        }
    }

    // show mensagem exceeds limit defined
    if (Object.hasOwn(states, "limitCharacters")) {
        if (states["limitCharacters"].isExceed) {
            spanWarningLimitValue.textContent = states["limitCharacters"].value;
            diVWarningLimit.setAttribute("aria-hidden", false);
        } else {
            diVWarningLimit.setAttribute("aria-hidden", true);
        }
        textArea.classList.toggle("form__text--error", states["limitCharacters"].isExceed);
        diVWarningLimit.classList.toggle("form__warning-limit-characters--active", states["limitCharacters"].isExceed);
    }
}

checkboxes.forEach(checkbox => checkbox.addEventListener("change", setting));
inputLimitCharacters.addEventListener("blur", captureTextRealTime);
textArea.addEventListener("input", captureTextRealTime);