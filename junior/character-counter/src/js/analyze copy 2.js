const textArea = document.querySelector(".form__text");
const checkboxes = document.querySelectorAll(".form__checkbox");
const inputLimit = document.querySelector(".form__input");
const spanCardsValue = document.querySelectorAll(".card__value");
const spanNoSpace = document.querySelector(".card__title-no-space");

const patternLimitInput = /[^0-9]/g; // generated by IA 
const patternExcludeSpaces = /[\s]/g; // generated by IA
const patternWords = /\p{L}+/gu; // generated by IA
const patterSentence = /[^.]+\./g; // generated by IA
let isCheckedExcludeSpaces = false;
let limitedCharactersDefined;


// active exclude spaces
function activeExcludeSpaces(checkbox) {
    const text = textArea.value;
    isCheckedExcludeSpaces = checkbox.checked;
    updateCharactersStats(text);
}

// Update the result in the cards
function updateCharactersStats(text) {
    let characters = 0;
    let words = 0;
    let sentences = 0;
    if (isCheckedExcludeSpaces) {
        characters = countCharacters(text, "noSpaces");
    } else {
        characters = countCharacters(text, "original");
    }
    
    words = countWordsSenteces(text, "original").totalWords;
    sentences = countWordsSenteces(text, "original").totalSentences;
    showStats({ characters, words, sentences });
    showNoSpaceMsg();
}

// exclude spaces characters
function excludeSpaces(text) {
    return text.replace(patternExcludeSpaces, "");
}

// show the input to define limite of characters
function showInputLimitCharacters(checkbox) {
    if (checkbox.checked) {
        inputLimit.setAttribute("aria-hidden", "false");
        inputLimit.classList.add("form__input--active");
        inputLimit.focus();
    } else {
        inputLimit.setAttribute("aria-hidden", "true");
        inputLimit.classList.remove("form__input--active");
        inputLimit.value = "";
        limitedCharactersDefined = undefined;
    }
}

// Sanitize input when the user types letter and symbols
inputLimit.addEventListener("input", () => {
    inputLimit.value = inputLimit.value.replace(patternLimitInput, "");
});

// define limit of characters
function defineLimitCharacters() {
    const value = Number(inputLimit.value);
    limitedCharactersDefined = value > 0 ? checkLimitCharacters(value) : undefined;
}

function checkLimitCharacters(limitValue){
    

}

// define the checkbox selected 
function setting(e) {
    const selectedOption = e.target;
    switch (selectedOption.id) {
        case "exclude-spaces":
            activeExcludeSpaces(selectedOption)
            break;
        case "limit-caracters":
            showInputLimitCharacters(selectedOption);
            break;
        default:
    }
}

// count the characters by type of the text. Exclude spaces or original 
function countCharacters(text, typeText) {
    const value = typeText === "noSpaces" ? excludeSpaces(text).length : text.length;
    return value;
}

// input of the caracteres
function captureTextRealTime() {
    const text = textArea.value.trim();
    updateCharactersStats(text);
}

// count the words and senteces
function countWordsSenteces(text) {
    const totalCharacters = countCharacters(text, "original");
    const totalWords = totalCharacters > 0 ? text.match(patternWords).length : 0;
    const totalSentences = totalCharacters > 0 && text.match(patterSentence) ? text.match(patterSentence).length : 0;
    return { totalWords, totalSentences }
}

// show the values in the stats on the cards
function showStats(typeStats) {
    spanCardsValue.forEach(card => {
        if (Object.hasOwn(typeStats, card.id)) {
            card.textContent = typeStats[card.id] > 0 ? typeStats[card.id].toString().padStart(2, "0") : "00";
        }
    })
}

// show the message "No Space" in the the count characters card
function showNoSpaceMsg() {
    if (isCheckedExcludeSpaces) {
        spanNoSpace.classList.add("card__title-no-space--active");
        spanNoSpace.setAttribute("aria-hidden", "false");
    } else {
        spanNoSpace.classList.remove("card__title-no-space--active");
        spanNoSpace.setAttribute("aria-hidden", "true");
    }
}

checkboxes.forEach(checkbox => checkbox.addEventListener("change", setting));
inputLimit.addEventListener("blur", defineLimitCharacters)
textArea.addEventListener("input", captureTextRealTime);